# -*- coding: utf-8 -*-
"""修正後的LINE Bot主程式

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TdU5L9jiAg_T31oJeXoZJPVNwlR3bIVY
"""

# -*- coding: utf-8 -*-
"""LINE Bot 主程式 (已整合支付方式管理頁面)"""

import os
import json
import configparser
from flask import Flask, request, abort
from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.messaging import (
    Configuration,
    ApiClient,
    MessagingApi,
    ReplyMessageRequest,
    PushMessageRequest,
    TextMessage, # 確保這裡引入的是 TextMessage
    TemplateMessage,
    ButtonsTemplate,
    PostbackAction,
    URIAction,
    QuickReply,
    QuickReplyItem,
    MessageAction
)
from linebot.v3.webhooks import FollowEvent, MessageEvent, PostbackEvent, TextMessageContent
import google.generativeai as genai
import logging

# 移除重複且棄用的 import
# from linebot.models import MessageEvent, TextMessage, TextMessage

# --- 組態設定 (從 config.ini 讀取) ---
config = configparser.ConfigParser()
config.read('config.ini', encoding='utf-8')

import db # 假設 connect_db 模組提供 get_db_connection()

# LINE 設定
LINE_CHANNEL_ACCESS_TOKEN = config.get('LINE', 'CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = config.get('LINE', 'CHANNEL_SECRET')
LIFF_PAYMENT_MANAGER_URL = config.get('LINE', 'LIFF_PAYMENT_MANAGER_URL')

# Gemini 設定
GEMINI_API_KEY = config.get('GEMINI', 'API_KEY')
def get_gemini_api_key(config_file='config.ini'):
    """
    從 config.ini 檔案中讀取 Gemini API Key。
    """
    config = configparser.ConfigParser()

    # 檢查 config.ini 檔案是否存在
    if not os.path.exists(config_file):
        raise FileNotFoundError(f"錯誤：找不到 '{config_file}' 檔案。請確認檔案是否存在。")

    config.read(config_file)

    if 'GEMINI' not in config:
        raise ValueError(f"錯誤：'{config_file}' 中缺少 '[GEMINI]' 區段。")

    if 'API_KEY' not in config['GEMINI']:
        raise ValueError(f"錯誤：'{config_file}' 的 '[GEMINI]' 區段中缺少 'API_KEY'。")

    return config['GEMINI']['API_KEY']


# --- 初始化 ---
app = Flask(__name__)

# --- 設定日誌 ---
log_handler = logging.FileHandler('app.log', encoding='utf-8') # 設定日誌檔案
app.logger.addHandler(log_handler)
app.logger.setLevel(logging.INFO) # 設定日誌等級為 INFO

# LINE Bot API 設定
configuration = Configuration(access_token=LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# Gemini API 設定
GEMINI_API_KEY = get_gemini_api_key()
genai.configure(api_key=GEMINI_API_KEY)
gemini_model = genai.GenerativeModel('gemini-2.5-flash')

# 使用者狀態追蹤 (簡易版，正式上線建議使用 Redis 或資料庫)
user_states = {}

# --- 資料庫輔助函式 (假設 connect_db 模組提供 get_db_connection) ---
# 確保 connect_db 模組中的 get_db_connection 函數能正確返回資料庫連線
get_db_connection = db.get_db_connection

# 管理支付方式連結
# 注意: 這裡的 payment_manager_url 應該只包含 LIFF 的基礎 URL，user_id 應該在 LIFF 頁面中動態獲取或透過參數傳遞
# 這裡將其修正為直接使用 LIFF_PAYMENT_MANAGER_URL
# payment_manager_url = f"https://personalproject-je9f.onrender.com/userid/"
# payment_manager_url = f"https://2b0d0b6ebaa4.ngrok-free.app/userid/"


def get_payment_options(type_filter):
    print('從資料庫獲取支付選項')
    conn = get_db_connection()
    if not conn: return []
    with conn.cursor() as cursor:
        cursor.execute("SELECT id, name, open_url, apply_url, type FROM payment_options WHERE type = %s", (type_filter,))
        result = cursor.fetchall()
    conn.close()
    return result

def get_all_payment_options():
    print('從資料庫獲取所有支付選項')
    conn = get_db_connection()
    if not conn: return []
    with conn.cursor() as cursor:
        cursor.execute("SELECT id, name, open_url, apply_url, type FROM payment_options")
        result = cursor.fetchall()
    conn.close()
    return result

def get_user_id(line_user_id):
    print('根據 line_user_id 查找或建立使用者，並返回資料庫 user.id')
    conn = get_db_connection()
    if not conn: return None
    with conn.cursor() as cursor:
        cursor.execute("SELECT id FROM users WHERE line_user_id = %s", (line_user_id,))
        user = cursor.fetchone()
        if user:
            user_id = user['id']
        else:
            cursor.execute("INSERT INTO users (line_user_id) VALUES (%s)", (line_user_id,))
            conn.commit()
            user_id = cursor.lastrowid
    conn.close()
    return user_id

def get_user_payment_methods(user_id):
    print('獲取使用者已有的支付工具')
    conn = get_db_connection()
    if not conn: return [], []
    with conn.cursor() as cursor:
        sql = """
            SELECT po.name, po.type, po.open_url, po.apply_url
            FROM user_payment_methods upm
            JOIN payment_options po ON upm.payment_option_id = po.id
            WHERE upm.user_id = %s
        """
        cursor.execute(sql, (user_id,))
        methods = cursor.fetchall()
    conn.close()

    mobile_payments = [m for m in methods if m['type'] == 'mobile']
    credit_cards = [m for m in methods if m['type'] == 'credit_card']

    return mobile_payments, credit_cards

# --- 接收 user id 並 redirect ---
# app route 用於接收 user id 並重定向到支付方式管理頁面
@app.route("/userid/<user_id>")
def redirect_to_payment_manager(user_id):
    print('接收 user id 並重定向到支付方式管理頁面')
    if not user_id:
        app.logger.error("未提供有效的 user_id")
        return "錯誤：未提供有效的 user_id", 400

    # 構建重定向 URL
    # 這裡直接使用 LIFF_PAYMENT_MANAGER_URL，並將 user_id 作為查詢參數傳遞
    redirect_url = f"{LIFF_PAYMENT_MANAGER_URL}?user_id={user_id}"
    app.logger.info(f"Redirecting to payment manager: {redirect_url}")
    # 使用 JavaScript 進行重定向，確保 LIFF 頁面能正確接收 user_id
    return f'<html><body><script>window.location.href="{redirect_url}";</script></body></html>', 302

# --- LINE Bot 主要路由 ---
@app.route("/callback", methods=['POST'])
def callback():
    print('接收 LINE Webhook 的主要進入點')
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    app.logger.info("Request body: " + body)
    try:
        app.logger.info("Handling webhook event with signature: " + signature)
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature. Please check your channel secret.")
        abort(400)
    except Exception as e:
        app.logger.error(f"An unexpected error occurred in handler: {e}")
    return 'OK'

# --- LINE 事件處理器 ---
@handler.add(FollowEvent)
def handle_follow(event):
    print('處理 "加入好友" 事件')
    app.logger.info(f"FollowEvent received for user: {event.source.user_id}")
    line_user_id = event.source.user_id
    get_user_id(line_user_id) # 確保使用者已在資料庫中

    # 修正: 使用 TextMessage 並呼叫 .to_dict()
    reply_message = TextMessage(text="歡迎使用 回饋達人！\n請點擊下方選單開始。").to_dict()

    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)
        try:
            # 步驟 1: 使用 reply_token 回覆歡迎文字
            app.logger.info("Replying with welcome text.")
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[reply_message] # 這裡已經是字典格式
                )
            )

            # 步驟 2: 使用 push_message 主動推送主選單
            app.logger.info("Pushing main menu.")
            # 修正: create_main_menu 返回的是 TemplateMessage 物件，需要呼叫 .to_dict()
            main_menu_message = create_main_menu(line_user_id).to_dict()
            line_bot_api.push_message(
                PushMessageRequest(
                    to=line_user_id,
                    messages=[main_menu_message] # 這裡已經是字典格式
                )
            )
        except Exception as e:
            app.logger.error(f"Error in handle_follow: {e}")

@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    app.logger.info('處理文字訊息事件')
    text = event.message.text
    line_user_id = event.source.user_id
    reply_token = event.reply_token
    app.logger.info(f"MessageEvent received from {line_user_id}: '{text}'")
    state = user_states.get(line_user_id)

    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)

        try:
            if text == "智慧消費推薦":
                app.logger.info("Matched '智慧消費推薦', starting consumption flow.")
                start_consumption_flow(line_user_id, reply_token, line_bot_api)
            # 處理「管理支付方式」選項
            elif text == "管理支付方式":
                app.logger.info("Matched '管理支付方式', opening payment manager LIFF.")
                user_db_id = get_user_id(line_user_id) # 獲取資料庫中的 user_id
                if user_db_id:
                    # 構建 LIFF URL，將 user_id 作為參數傳遞
                    # 修正: URIAction 的 uri 參數應該是完整的 LIFF URL，而不是拼接字符串
                    # 這裡直接使用 LIFF_PAYMENT_MANAGER_URL 並加上查詢參數
                    liff_url_with_param = f"{LIFF_PAYMENT_MANAGER_URL}?user_id={user_db_id}"

                    # 修正: TextMessage 和 TemplateMessage 都需要 .to_dict()
                    messages_to_reply = [
                        TextMessage(text="請點擊下方連結管理您的支付方式：").to_dict(),
                        TemplateMessage(
                            alt_text="管理支付方式",
                            template=ButtonsTemplate(
                                title='支付方式管理',
                                text='點擊按鈕進入設定頁面',
                                actions=[
                                    URIAction(label='前往管理', uri=liff_url_with_param) # 使用正確的 LIFF URL
                                ]
                            )
                        ).to_dict()
                    ]
                    line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=messages_to_reply
                        )
                    )
                else:
                    # 修正: TextMessage 需要 .to_dict()
                    line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=[TextMessage(text="抱歉，無法獲取您的用戶ID，請稍後再試。").to_dict()]
                        )
                    )
            elif state and state.get('step') == 'awaiting_category':
                app.logger.info("State is 'awaiting_category'.")
                state['category'] = text
                state['step'] = 'awaiting_amount'
                # 修正: TextMessage 需要 .to_dict()
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=reply_token,
                        messages=[TextMessage(text=f"好的，消費類別是「{text}」。\n請輸入您的預估消費金額（純數字）：").to_dict()]
                    )
                )
            elif state and state.get('step') == 'awaiting_amount':
                app.logger.info("State is 'awaiting_amount'.")
                if text.isdigit():
                    state['amount'] = int(text)
                    state['step'] = 'done'
                    get_gemini_recommendation(line_user_id, reply_token, line_bot_api)
                    user_states.pop(line_user_id, None) # 清除狀態
                else:
                    # 修正: TextMessage 需要 .to_dict()
                    line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=[TextMessage(text="請輸入有效的純數字金額。").to_dict()]
                        )
                    )
            else:
                app.logger.info("No match found, sending main menu as default.")
                # 修正: create_main_menu 返回的是 TemplateMessage 物件，需要呼叫 .to_dict()
                main_menu_message = create_main_menu(line_user_id).to_dict()
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=reply_token,
                        messages=[main_menu_message]
                    )
                )
        except Exception as e:
            app.logger.error(f"Error in handle_message: {e}")
            # --- 直接用網址連接支付方式管理頁面 (此段邏輯與上方重複，建議合併) ---
            # 這裡的 except 區塊中再次處理 "管理支付方式" 可能會導致重複邏輯或非預期行為
            # 建議將此段移除，讓上方的 if/elif 邏輯處理所有情況
            # if text == "管理支付方式":
            #     app.logger.info("Matched '管理支付方式', opening payment manager URL.")
            #     user_db_id = get_user_id(line_user_id) # 獲取資料庫中的 user_id
            #     if user_db_id:
            #         payment_manager_url_for_uri = f"{LIFF_PAYMENT_MANAGER_URL}?user_id={user_db_id}" # 修正為 LIFF_PAYMENT_MANAGER_URL
            #         line_bot_api.reply_message(
            #             ReplyMessageRequest(
            #                 reply_token=reply_token,
            #                 messages=[
            #                     TextMessage(text="請點擊下方連結管理您的支付方式：").to_dict(),
            #                     TemplateMessage(
            #                         alt_text="管理支付方式",
            #                         template=ButtonsTemplate(
            #                             title='支付方式管理',
            #                             text='點擊按鈕進入設定頁面',
            #                             actions=[
            #                                 URIAction(label='前往管理', uri=payment_manager_url_for_uri)
            #                             ]
            #                         )
            #                     ).to_dict()
            #                 ]
            #             )
            #         )
            #     else:
            #         line_bot_api.reply_message(
            #             ReplyMessageRequest(
            #                 reply_token=reply_token,
            #                 messages=[TextMessage(text="抱歉，無法獲取您的用戶ID，請稍後再試。").to_dict()]
            #             )
            #         )

@handler.add(PostbackEvent)
def handle_postback(event):
    print('處理 Postback 事件 (使用者點擊按鈕)')
    data = event.postback.data
    line_user_id = event.source.user_id
    reply_token = event.reply_token
    app.logger.info(f"PostbackEvent received from {line_user_id}: '{data}'")

    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)

        try:
            params = dict(x.split('=') for x in data.split('&'))
            action = params.get('action')

            # 目前此處不再有需要處理的 Postback，因為相關功能已轉移到 LIFF 網頁
            pass
        except Exception as e:
            app.logger.error(f"Error in handle_postback: {e}")

# --- 功能流程函式 ---
def create_main_menu(line_user_id):
    user_db_id = get_user_id(line_user_id)
    print('建立主選單 TemplateMessage')
    # 修正: URIAction 的 uri 參數應該是完整的 LIFF URL，並將 user_db_id 作為查詢參數傳遞
    # 而不是直接拼接在路徑後面，因為 LIFF_PAYMENT_MANAGER_URL 可能不包含 /userid/
    liff_url_for_main_menu = f"{LIFF_PAYMENT_MANAGER_URL}?user_id={user_db_id}"

    return TemplateMessage(
        alt_text='主選單',
        template=ButtonsTemplate(
            title='回饋達人',
            text='請選擇您要使用的服務：',
            actions=[
                MessageAction(label='智慧消費推薦', text='智慧消費推薦'),
                URIAction(label='管理支付方式', uri=liff_url_for_main_menu) # 使用修正後的 LIFF URL
            ]
        )
    )

def start_consumption_flow(line_user_id, reply_token, api: MessagingApi):
    print('開始消費推薦流程')
    user_states[line_user_id] = {'step': 'awaiting_category'}

    quick_reply_items = [
        QuickReplyItem(action=MessageAction(label=cat, text=cat))
        for cat in ["餐飲", "購物", "交通", "娛樂", "網購"]
    ]

    # 建立 TextMessage 物件，並呼叫 .to_dict()
    text_message_content = TextMessage(
        text="請告訴我這次的消費類別是什麼？\n(例如：餐飲、購物、繳費...)\n或直接點選下方建議類別。",
        quick_reply=QuickReply(items=quick_reply_items)
    ).to_dict() # 這裡直接轉換為字典

    # 回覆訊息給用戶
    api.reply_message(
        ReplyMessageRequest(
            reply_token=reply_token,
            messages=[text_message_content] # 使用已經轉換為字典的訊息
        )
    )

def get_gemini_recommendation(line_user_id, reply_token, api: MessagingApi):
    print('呼叫 Gemini API 並回覆推薦結果')
    state = user_states.get(line_user_id)
    if not state: return

    user_id = get_user_id(line_user_id)
    category = state.get('category')
    amount = state.get('amount')

    mobile_payments, credit_cards = get_user_payment_methods(user_id)
    user_methods_str = ", ".join([p['name'] for p in mobile_payments] + [c['name'] for c in credit_cards])
    if not user_methods_str: user_methods_str = "無"

    all_options = get_all_payment_options()
    all_options_str = ", ".join([opt['name'] for opt in all_options])

    # 確保 prompt 中的使用者擁有的支付工具是從資料庫動態獲取的
    prompt = f"""
    你是一位台灣地區的信用卡與行動支付優惠專家。請根據以下資訊，為使用者提供支付建議。

    # 使用者資訊
    - **本次消費類別**: {category}
    - **預估消費金額**: {amount}元
    - **使用者目前擁有的支付工具**: {user_methods_str}

    # 任務
    請嚴格按照指定的 JSON 格式回傳，不要有任何額外的文字或解釋。

    - **就使用者「已有」的支付工具**: 從他擁有的工具中，選出最適合這次消費的前 5 名，並標示回饋%數，及自動計算預估回饋金，然後顯示回饋金最高的前 3 名。如果他沒有任何工具，或沒有適合的，請在 `recommendations` 中回傳空陣列 `[]`。

    # JSON 格式範本
    {{
      "existing_tools_recommendation": {{
        "title": "使用您現有的工具，推薦如下(請注意高%數的限額)：",
        "recommendations": [
          {{"name": "支付工具名稱", "percent": "%數", "cashback": "n元", "reason": "推薦理由"}},
        ]
      }}
    }}
    """

    try:
        # 修正: TextMessage 需要 .to_dict()
        api.push_message(PushMessageRequest(to=line_user_id, messages=[TextMessage(text="正在為您分析最佳支付方式，請稍候...").to_dict()]))

        response = gemini_model.generate_content(prompt)

        cleaned_response_text = response.text.strip().replace("```json", "").replace("```", "")
        recommendations = json.loads(cleaned_response_text)

        print("刷卡內容：", user_id, category, amount, recommendations, "\n")
        save_transaction(user_id, category, amount, recommendations)

        # format_recommendation_messages 應該返回已經 .to_dict() 的訊息列表
        reply_messages = format_recommendation_messages(recommendations)
        print("回覆訊息：", reply_messages, "\n")
        api.push_message(PushMessageRequest(to=line_user_id, messages=reply_messages))

    except Exception as e:
        app.logger.error(f"Gemini API 或後續處理出錯: {e}")
        # 修正: TextMessage 需要 .to_dict()
        api.push_message(PushMessageRequest(to=line_user_id, messages=[TextMessage(text="抱歉，分析時發生錯誤，請稍後再試。").to_dict()]))


def format_recommendation_messages(reco_data):
    print('將 Gemini 回傳的 JSON 格式化為 LINE 的 TemplateMessage')
    messages = []
    all_payment_options = {opt['name']: opt for opt in get_all_payment_options()}

    # 處理現有工具推薦
    existing_reco = reco_data.get('existing_tools_recommendation')
    if existing_reco and existing_reco.get('recommendations'):
        # messages.append(TextMessage(text=existing_reco.get('title', '現有工具推薦：')))
        # 修正: 清空 messages 列表，並直接添加格式化後的訊息
        messages = []
        for item in existing_reco['recommendations']:
            name = item.get('name')
            percent = item.get('percent', 0)
            cashback = item.get('cashback', '0元')
            reason = name + "：" +item.get('reason', '無特別理由')
            option_details = all_payment_options.get(name)

            action = None
            # if option_details and option_details.get('type') == 'mobile' and option_details.get('open_url'):
            #     action = URIAction(label="開啟 APP", uri=option_details.get('open_url'))

            if action:
                # 修正: TemplateMessage 需要 .to_dict()
                messages.append(TemplateMessage(
                    alt_text=f"推薦：{name}",
                    template=ButtonsTemplate(title=f"推薦使用：{name}", text=reason, actions=[action])
                ).to_dict())
            else:
                # 修正: TemplateMessage 需要 .to_dict()
                # 這裡的 TemplateMessage 結構看起來有點奇怪，ButtonsTemplate 通常需要一個 title
                # 如果只是顯示文字，用 TextMessage 更合適。
                # 假設您想顯示一個按鈕，點擊後顯示詳情
                messages.append(TemplateMessage(
                    alt_text="推薦理由",
                    template=ButtonsTemplate(
                        title=f"【{name}】", # 增加 title
                        text=f"預估回饋：{percent} 回饋金：{cashback}",
                        actions=[MessageAction(label='查看詳情', text=reason)]
                    )
                ).to_dict())
    else:
        # 修正: TextMessage 需要 .to_dict()
        messages.append(TextMessage(text="您現有的支付工具中，本次消費沒有特別合適的推薦。").to_dict())

    # 處理新工具推薦 (保持原樣，因為被註釋掉了)
    #new_reco = reco_data.get('new_tools_recommendation')
    #if new_reco and new_reco.get('recommendations'):
    #    messages.append(TextMessage(text="---").to_dict()) # 分隔線
    #    messages.append(TextMessage(text=new_reco.get('title', '新工具推薦：')).to_dict())
    #
    #    for item in new_reco['recommendations']:
    #        name = item.get('name')
    #        reason = item.get('reason')
    #        option_details = all_payment_options.get(name)
    #
    #        action = None
    #        if option_details and option_details.get('apply_url'):
    #            action = URIAction(label="前往申辦", uri=option_details.get('apply_url'))
    #
    #        if action:
    #            messages.append(TemplateMessage(
    #                alt_text=f"可考慮申辦：{name}",
    #                template=ButtonsTemplate(title=f"可考慮申辦：{name}", text=reason, actions=[action])
    #            ).to_dict())
    #        else:
    #            messages.append(TextMessage(text=f"【建議申辦：{name}】\n{reason}").to_dict())

    if not messages:
        # 修正: TextMessage 需要 .to_dict()
        return [TextMessage(text="抱歉，目前無法提供有效的建議。").to_dict()]

    return messages


def save_transaction(user_id, category, amount, recommendations):
    print('將交易與推薦結果存入資料庫')
    conn = get_db_connection()
    if not conn: return

    with conn.cursor() as cursor:
        sql = """
            INSERT INTO transactions (user_id, category, amount, recommended_options)
            VALUES (%s, %s, %s, %s)
        """
        cursor.execute(sql, (user_id, category, amount, json.dumps(recommendations, ensure_ascii=False)))
    conn.commit()
    conn.close()

# --- 主程式進入點 ---
if __name__ == "__main__":
    print('主程式進入點')
    port = int(os.environ.get('PORT', 50000))
    app.run(host='0.0.0.0', port=port)