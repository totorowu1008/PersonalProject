# -*- coding: utf-8 -*-
"""app.py - LINE Bot 主程式與 Flask 應用程式

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nBMUmPXlJTz_KoNWe9_Wu_NzgG8Fhzz9
"""

# app.py
# -*- coding: utf-8 -*-
import os
import json
import pymysql
import configparser
from flask import Flask, request, abort, render_template, redirect, url_for, jsonify
from linebot.v3 import WebhookHandler
from linebot.v3.exceptions import InvalidSignatureError
from linebot.v3.messaging import (
    Configuration,
    ApiClient,
    MessagingApi,
    ReplyMessageRequest,
    PushMessageRequest,
    TextMessage,
    TemplateMessage,
    ButtonsTemplate,
    PostbackAction,
    URIAction,
    QuickReply,
    QuickReplyItem,
    MessageAction
)
from linebot.v3.webhooks import MessageEvent, PostbackEvent, FollowEvent, TextMessageContent
import google.generativeai as genai
import logging
from db import get_db_connection # 引入獨立的資料庫連線模組

# --- 組態設定 (從 config.ini 讀取) ---
config = configparser.ConfigParser()
config_path = os.path.join(os.path.dirname(__file__), 'config.ini')
if not os.path.exists(config_path):
    raise FileNotFoundError(f"錯誤：找不到 '{config_path}' 檔案。請確認檔案是否存在。")
config.read(config_path, encoding='utf-8')

# LINE 設定
LINE_CHANNEL_ACCESS_TOKEN = config.get('LINE', 'CHANNEL_ACCESS_TOKEN')
LINE_CHANNEL_SECRET = config.get('LINE', 'CHANNEL_SECRET')
LIFF_PAYMENT_MANAGER_URL = config.get('LINE', 'LIFF_PAYMENT_MANAGER_URL') # 讀取 LIFF URL

# Gemini 設定
GEMINI_API_KEY = config.get('GEMINI', 'API_KEY')
genai.configure(api_key=GEMINI_API_KEY)
gemini_model = genai.GenerativeModel('gemini-2.5-flash')

# --- 初始化 Flask 應用程式 ---
app = Flask(__name__)

# --- 設定日誌 ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
app.logger.setLevel(logging.INFO) # 設定 Flask 應用程式的日誌等級為 INFO
logger = logging.getLogger(__name__)  # 新增 logger 變數

# LINE Bot API 設定
configuration = Configuration(access_token=LINE_CHANNEL_ACCESS_TOKEN)
handler = WebhookHandler(LINE_CHANNEL_SECRET)

# 使用者狀態追蹤 (簡易版，正式上線建議使用 Redis 或資料庫)
user_states = {}

# --- 資料庫操作輔助函式 ---
def get_payment_options_from_db(type_filter=None):
    """
    從資料庫獲取支付選項。
    可選參數 type_filter 用於篩選特定類型的支付方式 (e.g., 'mobile', 'credit_card')。
    """
    logger.info(f'從資料庫獲取支付選項, 篩選類型: {type_filter}')
    conn = get_db_connection()
    if not conn: return []
    try:
        with conn.cursor(pymysql.cursors.DictCursor) as cursor: # 確保回傳字典
            if type_filter:
                cursor.execute("SELECT id, name, open_url, apply_url, type FROM payment_options WHERE type = %s ORDER BY `rank`, id", (type_filter,))
            else:
                cursor.execute("SELECT id, name, open_url, apply_url, type FROM payment_options ORDER BY `type`, `rank`, id")
            result = cursor.fetchall()
    except Exception as e:
        logger.error(f"獲取支付選項時發生錯誤: {e}")
        result = []
    finally:
        conn.close()
    return result

def get_user_id(line_user_id):
    """
    根據 LINE user_id 查找或建立使用者，並返回資料庫中的 user.id。
    """
    logger.info(f'根據 line_user_id 查找或建立使用者: {line_user_id}')
    conn = get_db_connection()
    if not conn: return None
    try:
        with conn.cursor() as cursor:
            cursor.execute("SELECT id FROM users WHERE line_user_id = %s", (line_user_id,))
            user = cursor.fetchone()
            if user:
                user_id = user[0] # pymysql.cursors.Cursor 回傳 tuple
            else:
                cursor.execute("INSERT INTO users (line_user_id) VALUES (%s)", (line_user_id,))
                conn.commit()
                user_id = cursor.lastrowid
        logger.info(f"使用者 ID: {user_id}")
        return user_id
    except Exception as e:
        logger.error(f"獲取或建立使用者 ID 時發生錯誤: {e}")
        return None
    finally:
        conn.close()

def get_user_payment_methods(user_id):
    """
    獲取使用者已擁有的支付工具。
    回傳行動支付列表和信用卡列表。
    """
    logger.info(f'獲取使用者 {user_id} 已有的支付工具')
    conn = get_db_connection()
    if not conn: return [], []
    try:
        with conn.cursor(pymysql.cursors.DictCursor) as cursor:
            sql = """
                SELECT po.name, po.type, po.open_url, po.apply_url
                FROM user_payment_methods upm
                JOIN payment_options po ON upm.payment_option_id = po.id
                WHERE upm.user_id = %s
            """
            cursor.execute(sql, (user_id,))
            methods = cursor.fetchall()
    except Exception as e:
        logger.error(f"獲取使用者支付方式時發生錯誤: {e}")
        methods = []
    finally:
        conn.close()

    mobile_payments = [m for m in methods if m['type'] == 'mobile']
    credit_cards = [m for m in methods if m['type'] == 'credit_card']

    return mobile_payments, credit_cards

# --- LINE Bot 主要路由 ---
@app.route("/callback", methods=['POST'])
def callback():
    """
    接收 LINE Webhook 的主要進入點。
    驗證簽章並將事件轉發給處理器。
    """
    signature = request.headers['X-Line-Signature']
    body = request.get_data(as_text=True)
    app.logger.info("Request body: " + body)
    try:
        handler.handle(body, signature)
    except InvalidSignatureError:
        app.logger.error("Invalid signature. Please check your channel secret.")
        abort(400)
    except Exception as e:
        app.logger.error(f"在 Webhook 處理時發生意外錯誤: {e}")
    return 'OK'

# --- LINE 事件處理器 ---
@handler.add(FollowEvent)
def handle_follow(event):
    """
    處理 "加入好友" 事件。
    當用戶加入 Bot 為好友時，確保其 user_id 已在資料庫中，並發送歡迎訊息和主選單。
    """
    logger.info(f"收到 FollowEvent，用戶 ID: {event.source.user_id}")
    line_user_id = event.source.user_id
    get_user_id(line_user_id) # 確保使用者已在資料庫中

    welcome_message = TextMessage(text="歡迎使用 回饋達人！\n請點擊下方選單開始。")

    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)
        try:
            # 步驟 1: 使用 reply_token 回覆歡迎文字
            logger.info("回覆歡迎文字。")
            line_bot_api.reply_message(
                ReplyMessageRequest(
                    reply_token=event.reply_token,
                    messages=[welcome_message]
                )
            )

            # 步驟 2: 使用 push_message 主動推送主選單
            logger.info("推送主選單。")
            line_bot_api.push_message(
                PushMessageRequest(
                    to=line_user_id,
                    messages=[create_main_menu()]
                )
            )
        except Exception as e:
            logger.error(f"處理 FollowEvent 時發生錯誤: {e}")

@handler.add(MessageEvent, message=TextMessageContent)
def handle_message(event):
    """
    處理文字訊息事件。
    根據用戶輸入的文字，觸發不同的功能流程。
    """
    logger.info('處理文字訊息事件')
    text = event.message.text
    line_user_id = event.source.user_id
    reply_token = event.reply_token
    logger.info(f"從 {line_user_id} 收到訊息: '{text}'")
    state = user_states.get(line_user_id)

    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)

        try:
            # 將「基本資料設定」改為「設定支付方式」
            if text == "設定支付方式":
                logger.info("匹配到 '設定支付方式'，開啟支付管理 LIFF。")
                user_db_id = get_user_id(line_user_id) # 獲取資料庫中的 user_id
                user_db_id = 1
                if user_db_id:
                    # 構建 LIFF URL，將 user_id 作為參數傳遞
                    liff_url_with_param = f"{LIFF_PAYMENT_MANAGER_URL}?user_id={user_db_id}"
                    line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=[
                                TextMessage(text="請點擊下方連結管理您的支付方式："),
                                TemplateMessage(
                                    alt_text="管理支付方式",
                                    template=ButtonsTemplate(
                                        title='支付方式管理',
                                        text='點擊按鈕進入設定頁面',
                                        actions=[
                                            URIAction(label='前往管理', uri=liff_url_with_param)
                                        ]
                                    )
                                )
                            ]
                        )
                    )
                else:
                    line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=[TextMessage(text="抱歉，無法獲取您的用戶ID，請稍後再試。")]
                        )
                    )
            elif text == "智慧消費推薦":
                logger.info("匹配到 '智慧消費推薦'，開始消費流程。")
                start_consumption_flow(line_user_id, reply_token, line_bot_api)
            elif state and state.get('step') == 'awaiting_category':
                logger.info("狀態為 'awaiting_category'。")
                state['category'] = text
                state['step'] = 'awaiting_amount'
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=reply_token,
                        messages=[TextMessage(text=f"好的，消費類別是「{text}」。\n請輸入您的預估消費金額（純數字）：")]
                    )
                )
            elif state and state.get('step') == 'awaiting_amount':
                logger.info("狀態為 'awaiting_amount'。")
                if text.isdigit():
                    state['amount'] = int(text)
                    state['step'] = 'done'
                    get_gemini_recommendation(line_user_id, reply_token, line_bot_api)
                    user_states.pop(line_user_id, None) # 清除狀態
                else:
                    line_bot_api.reply_message(
                        ReplyMessageRequest(
                            reply_token=reply_token,
                            messages=[TextMessage(text="請輸入有效的純數字金額。")]
                        )
                    )
            else:
                logger.info("未匹配到任何指令，發送主選單作為預設回覆。")
                line_bot_api.reply_message(
                    ReplyMessageRequest(
                        reply_token=reply_token,
                        messages=[create_main_menu()]
                    )
                )
        except Exception as e:
            logger.error(f"處理文字訊息時發生錯誤: {e}")

@handler.add(PostbackEvent)
def handle_postback(event):
    """
    處理 Postback 事件 (使用者點擊按鈕)。
    """
    logger.info('處理 Postback 事件')
    data = event.postback.data
    line_user_id = event.source.user_id
    reply_token = event.reply_token
    logger.info(f"從 {line_user_id} 收到 Postback 事件: '{data}'")

    with ApiClient(configuration) as api_client:
        line_bot_api = MessagingApi(api_client)

        try:
            params = dict(x.split('=') for x in data.split('&'))
            action = params.get('action')

            if action == 'register_mobile':
                handle_mobile_selection(line_user_id, params, reply_token, line_bot_api)
            elif action == 'register_card':
                handle_card_selection(line_user_id, params, reply_token, line_bot_api)
        except Exception as e:
            logger.error(f"處理 Postback 事件時發生錯誤: {e}")

# --- 功能流程函式 ---
def create_main_menu():
    """
    建立 LINE Bot 的主選單 TemplateMessage。
    將「基本資料設定」按鈕改為「設定支付方式」。
    """
    logger.info('建立主選單 TemplateMessage')
    return TemplateMessage(
        alt_text='主選單',
        template=ButtonsTemplate(
            title='回饋達人',
            text='請選擇您要使用的服務：',
            actions=[
                MessageAction(label='設定支付方式', text='設定支付方式'), # 修改按鈕文字
                MessageAction(label='智慧消費推薦', text='智慧消費推薦'),
                # 這裡的 URIAction 雖然指向 LIFF URL，但實際點擊會由 LINE App 處理，
                # 並在 handle_message 中根據收到的「設定支付方式」文字來發送 LIFF 連結。
                # 這個按鈕主要是為了讓用戶可以直接點擊，而不是打字。
                # 實際的 LIFF 開啟會透過 TextMessage 觸發。
                # 為了避免重複，這裡可以移除或調整為其他功能。
                # 由於用戶要求點擊後跳轉，所以保留 MessageAction 觸發 TextMessage 處理。
            ]
        )
    )

def start_registration(line_user_id, reply_token, api: MessagingApi):
    """
    開始註冊流程，詢問行動支付。
    (此函數在新的流程中可能不再直接使用，因為改為 LIFF 網頁設定)
    """
    logger.info('開始註冊流程，詢問行動支付 (此流程可能被 LIFF 取代)')
    user_states[line_user_id] = {'step': 'register_mobile', 'selections': []}

    mobile_options = get_payment_options_from_db('mobile')
    quick_reply_items = [
        QuickReplyItem(action=PostbackAction(label=opt['name'], data=f"action=register_mobile&id={opt['id']}", display_text=f"選擇 {opt['name']}"))
        for opt in mobile_options
    ]
    quick_reply_items.append(QuickReplyItem(action=PostbackAction(label="都沒有/選完了", data="action=register_mobile&id=done", display_text="都沒有/選完了")))

    api.reply_message(
        ReplyMessageRequest(
            reply_token=reply_token,
            messages=[TextMessage(text="請選擇您擁有的行動支付（可複選），完成後請按「都沒有/選完了」。", quick_reply=QuickReply(items=quick_reply_items))]
        )
    )

def handle_mobile_selection(line_user_id, params, reply_token, api: MessagingApi):
    """
    處理行動支付選擇。
    (此函數在新的流程中可能不再直接使用，因為改為 LIFF 網頁設定)
    """
    logger.info('處理行動支付選擇 (此流程可能被 LIFF 取代)')
    state = user_states.get(line_user_id)
    if not state or state.get('step') != 'register_mobile':
        return

    selection_id = params.get('id')
    if selection_id == 'done':
        ask_for_credit_cards(line_user_id, reply_token, api)
    else:
        if selection_id not in state['selections']:
            state['selections'].append(selection_id)
        api.reply_message(
            ReplyMessageRequest(
                reply_token=reply_token,
                messages=[TextMessage(text=f"已加入選擇。請繼續選擇或按「都沒有/選完了」。")]
            )
        )

def ask_for_credit_cards(line_user_id, reply_token, api: MessagingApi):
    """
    詢問信用卡。
    (此函數在新的流程中可能不再直接使用，因為改為 LIFF 網頁設定)
    """
    logger.info('詢問信用卡 (此流程可能被 LIFF 取代)')
    state = user_states.get(line_user_id)
    state['step'] = 'register_card'
    state['mobile_selections'] = state.pop('selections', [])
    state['selections'] = []

    card_options = get_payment_options_from_db('credit_card')
    quick_reply_items = [
        QuickReplyItem(action=PostbackAction(label=opt['name'], data=f"action=register_card&id={opt['id']}", display_text=f"選擇 {opt['name']}"))
        for opt in card_options
    ]
    quick_reply_items.append(QuickReplyItem(action=PostbackAction(label="都沒有/選完了", data="action=register_card&id=done", display_text="都沒有/選完了")))

    api.reply_message(
        ReplyMessageRequest(
            reply_token=reply_token,
            messages=[TextMessage(text="接下來，請選擇您擁有的信用卡（可複選），完成後請按「都沒有/選完了」。", quick_reply=QuickReply(items=quick_reply_items))]
        )
    )

def handle_card_selection(line_user_id, params, reply_token, api: MessagingApi):
    """
    處理信用卡選擇並儲存到資料庫。
    (此函數在新的流程中可能不再直接使用，因為改為 LIFF 網頁設定)
    """
    logger.info('處理信用卡選擇並儲存到資料庫 (此流程可能被 LIFF 取代)')
    state = user_states.get(line_user_id)
    if not state or state.get('step') != 'register_card':
        return

    selection_id = params.get('id')
    if selection_id == 'done':
        user_id = get_user_id(line_user_id)
        all_selections = state.get('mobile_selections', []) + state.get('selections', [])

        conn = get_db_connection()
        if conn:
            try:
                with conn.cursor() as cursor:
                    cursor.execute("DELETE FROM user_payment_methods WHERE user_id = %s", (user_id,))
                    if all_selections:
                        values = [(user_id, int(pid)) for pid in all_selections]
                        logger.info(f"儲存支付方式：{values}")
                        cursor.executemany("INSERT INTO user_payment_methods (user_id, payment_option_id) VALUES (%s, %s)", values)
                conn.commit()
            except Exception as e:
                logger.error(f"儲存支付方式到資料庫時發生錯誤: {e}")
                if conn: conn.rollback()
            finally:
                conn.close()

        user_states.pop(line_user_id, None)
        api.reply_message(
            ReplyMessageRequest(
                reply_token=reply_token,
                messages=[TextMessage(text="基本資料設定完成！")]
            )
        )
    else:
        if selection_id not in state['selections']:
            state['selections'].append(selection_id)
        api.reply_message(
            ReplyMessageRequest(
                reply_token=reply_token,
                messages=[TextMessage(text=f"已加入選擇。請繼續選擇或按「都沒有/選完了」。")]
            )
        )

def start_consumption_flow(line_user_id, reply_token, api: MessagingApi):
    """
    開始消費推薦流程，詢問消費類別。
    """
    logger.info('開始消費推薦流程')
    user_states[line_user_id] = {'step': 'awaiting_category'}

    quick_reply_items = [
        QuickReplyItem(action=MessageAction(label=cat, text=cat))
        for cat in ["餐飲", "購物", "交通", "娛樂", "網購"]
    ]

    api.reply_message(
        ReplyMessageRequest(
            reply_token=reply_token,
            messages=[TextMessage(
                text="請告訴我這次的消費類別是什麼？\n(例如：餐飲、購物、繳費...)\n或直接點選下方建議類別。",
                quick_reply=QuickReply(items=quick_reply_items)
            )]
        )
    )

def get_gemini_recommendation(line_user_id, reply_token, api: MessagingApi):
    """
    呼叫 Gemini API 並回覆推薦結果。
    """
    logger.info('呼叫 Gemini API 並回覆推薦結果')
    state = user_states.get(line_user_id)
    if not state: return

    user_id = get_user_id(line_user_id)
    category = state.get('category')
    amount = state.get('amount')

    mobile_payments, credit_cards = get_user_payment_methods(user_id)
    user_methods_str = ", ".join([p['name'] for p in mobile_payments] + [c['name'] for c in credit_cards])
    if not user_methods_str: user_methods_str = "無"

    all_options = get_payment_options_from_db() # 獲取所有支付選項
    all_options_str = ", ".join([opt['name'] for opt in all_options])

    # 確保 prompt 中的使用者擁有的支付工具是從資料庫動態獲取的
    prompt = f"""
    你是一位台灣地區的信用卡與行動支付優惠專家。請根據以下資訊，為使用者提供支付建議。

    # 使用者資訊
    - **本次消費類別**: {category}
    - **預估消費金額**: {amount}元
    - **使用者目前擁有的支付工具**: {user_methods_str}

    # 任務
    請嚴格按照指定的 JSON 格式回傳，不要有任何額外的文字或解釋。

    - **就使用者「已有」的支付工具**: 從他擁有的工具中，推薦最適合這次消費的前 3 名，並標示回饋%數，並自動計算預估回饋金。如果他沒有任何工具，或沒有適合的，請在 `recommendations` 中回傳空陣列 `[]`。

    # JSON 格式範本
    {{
      "existing_tools_recommendation": {{
        "title": "使用您現有的工具，推薦如下(請注意高%數的限額)：",
        "recommendations": [
          {{"name": "支付工具名稱", "percent": "%數", "cashback": "n元", "reason": "推薦理由"}},
        ]
      }}
    }}
    """

    try:
        api.push_message(PushMessageRequest(to=line_user_id, messages=[TextMessage(text="正在為您分析最佳支付方式，請稍候...")]))

        response = gemini_model.generate_content(prompt)

        # 清理 Gemini 回傳的文字，移除可能的 markdown 語法
        cleaned_response_text = response.text.strip().replace("```json", "").replace("```", "")
        recommendations = json.loads(cleaned_response_text)

        logger.info(f"刷卡內容： 用戶ID={user_id}, 類別={category}, 金額={amount}, 推薦={recommendations}")
        save_transaction(user_id, category, amount, recommendations)

        reply_messages = format_recommendation_messages(recommendations)
        logger.info(f"回覆訊息： {reply_messages}")
        api.push_message(PushMessageRequest(to=line_user_id, messages=reply_messages))

    except Exception as e:
        logger.error(f"Gemini API 或後續處理出錯: {e}")
        api.push_message(PushMessageRequest(to=line_user_id, messages=[TextMessage(text="抱歉，分析時發生錯誤，請稍後再試。")]))


def format_recommendation_messages(reco_data):
    """
    將 Gemini 回傳的 JSON 格式化為 LINE 的 TemplateMessage 訊息列表。
    """
    logger.info('將 Gemini 回傳的 JSON 格式化為 LINE 的 TemplateMessage')
    messages = []
    # 獲取所有支付選項的字典，方便查找 open_url/apply_url
    all_payment_options_dict = {opt['name']: opt for opt in get_payment_options_from_db()}

    # 處理現有工具推薦
    existing_reco = reco_data.get('existing_tools_recommendation')
    if existing_reco and existing_reco.get('recommendations'):
        for item in existing_reco['recommendations']:
            name = item.get('name')
            percent = item.get('percent', '0%') # 確保有預設值
            cashback = item.get('cashback', '0元') # 確保有預設值
            reason = item.get('reason', '無特別理由') # 確保有預設值

            # 組合顯示文字
            display_text = f"【{name}】\n預估回饋：{percent} 回饋金：{cashback}\n理由：{reason}"

            # 檢查是否有 open_url 或 apply_url
            option_details = all_payment_options_dict.get(name)
            actions = []
            if option_details and option_details.get('type') == 'mobile' and option_details.get('open_url'):
                actions.append(URIAction(label='開啟 APP', uri=option_details.get('open_url')))
            elif option_details and option_details.get('type') == 'credit_card' and option_details.get('apply_url'):
                actions.append(URIAction(label='前往申辦', uri=option_details.get('apply_url')))

            # 如果沒有特定的 URL 行動，則添加一個「查看詳情」的 MessageAction
            # 這裡將詳細理由放在 MessageAction 的 text 中，讓用戶點擊後可以再次看到
            if not actions:
                 actions.append(MessageAction(label='查看詳情', text=display_text))


            messages.append(TemplateMessage(
                alt_text=f"推薦：{name}",
                template=ButtonsTemplate(
                    title=f"推薦使用：{name}",
                    text=f"預估回饋：{percent} 回饋金：{cashback}", # 這裡顯示簡要信息
                    actions=actions
                )
            ))
    else:
        messages.append(TextMessage(text="您現有的支付工具中，本次消費沒有特別合適的推薦。"))

    if not messages:
        return [TextMessage(text="抱歉，目前無法提供有效的建議。")]

    return messages


def save_transaction(user_id, category, amount, recommendations):
    """
    將交易紀錄和 Gemini 推薦結果存入資料庫。
    """
    logger.info('將交易與推薦結果存入資料庫')
    conn = get_db_connection()
    if not conn: return

    try:
        with conn.cursor() as cursor:
            sql = """
                INSERT INTO transactions (user_id, category, amount, recommended_options)
                VALUES (%s, %s, %s, %s)
            """
            # 將 recommendations 字典轉換為 JSON 字串儲存
            cursor.execute(sql, (user_id, category, amount, json.dumps(recommendations, ensure_ascii=False)))
        conn.commit()
        logger.info("交易紀錄和推薦結果已成功儲存。")
    except Exception as e:
        logger.error(f"儲存交易紀錄時發生錯誤: {e}")
        if conn: conn.rollback()
    finally:
        conn.close()

# --- 支付方式管理網頁的 Flask 路由 ---
@app.route('/pmgr_web') # 修改路由名稱以避免與舊的 /pmgr 混淆
def pmgr_web():
    """
    處理支付方式管理網頁的顯示。
    從資料庫獲取現有的支付方式和用戶已選取的支付方式。
    """
    # 從 GET 參數中獲取 user_id，預設為 '1'
    user_id = request.args.get('user_id', '1')

    all_methods = []
    electronic_payments = []
    credit_cards = []
    other_methods = []
    selected_methods = []
    error_message = None

    db_conn = get_db_connection()
    if db_conn:
        try:
            cursor = db_conn.cursor(pymysql.cursors.DictCursor) # 使用字典 cursor

            # 獲取用戶已選取的支付方式 ID
            stmt = "SELECT payment_option_id FROM user_payment_methods WHERE user_id = %s"
            cursor.execute(stmt, (user_id,))
            selected_methods = [row['payment_option_id'] for row in cursor.fetchall()]

            # 獲取所有支付方式並按類型分組
            stmt = "SELECT id, name, type, `rank` FROM payment_options ORDER BY type, `rank`, id"
            cursor.execute(stmt)
            all_methods = cursor.fetchall()

            # 根據類型將支付方式分組
            electronic_payments = [m for m in all_methods if m['type'] == 'mobile']
            credit_cards = [m for m in all_methods if m['type'] == 'credit_card']
            other_methods = [m for m in all_methods if m['type'] not in ['mobile', 'credit_card']]

        except Exception as e:
            error_message = f"資料庫錯誤： {e}"
            logger.error(f"資料庫錯誤 (pmgr_web): {e}")
        finally:
            db_conn.close()
    else:
        error_message = "無法連線到資料庫。請檢查 db.py 設定或資料庫狀態。"

    # 渲染 HTML 模板並傳遞資料
    return render_template('pmgr.html',
                           user_id=user_id,
                           electronic_payments=electronic_payments,
                           credit_cards=credit_cards,
                           other_methods=other_methods,
                           selected_methods=selected_methods,
                           error_message=error_message)


@app.route('/payment_methods_save_web', methods=['POST']) # 修改路由名稱
def payment_methods_save_web():
    """
    處理支付方式網頁的儲存請求。
    清除用戶現有設定，然後插入新的支付方式和選取的現有支付方式。
    """
    user_id = request.form.get('user_id', '1') # 從表單獲取 user_id，預設為 '1'
    logger.info(f"接收到支付方式儲存請求，用戶ID: {user_id}")

    db_conn = get_db_connection()
    if db_conn:
        try:
            cursor = db_conn.cursor()

            # 清除該用戶現有的所有支付方式設定
            sql_delete = "DELETE FROM user_payment_methods WHERE user_id = %s"
            cursor.execute(sql_delete, (user_id,))
            logger.info(f"已清除用戶 {user_id} 的現有支付方式。")

            # 處理新增的支付方式 (最多兩個)
            for i in range(1, 3):
                new_method_name = request.form.get(f"new_method_{i}")
                new_method_type = request.form.get(f"new_method_{i}_type")

                # 檢查是否有提供新的支付方式名稱且不為空
                if new_method_name and new_method_name.strip():
                    rank = 100 # 預設排名
                    # 插入新的支付選項到 payment_options 表
                    sql_insert_option = "INSERT INTO payment_options (`name`, `type`, `rank`) VALUES (%s, %s, %s)"
                    cursor.execute(sql_insert_option, (new_method_name.strip(), new_method_type, rank))
                    new_method_id = cursor.lastrowid # 獲取新插入的支付選項 ID
                    logger.info(f"新增支付選項: {new_method_name} (ID: {new_method_id})")

                    # 將新支付選項與用戶關聯到 user_payment_methods 表
                    sql_insert_user_method = "INSERT INTO user_payment_methods (user_id, payment_option_id) VALUES (%s, %s)"
                    cursor.execute(sql_insert_user_method, (user_id, new_method_id))
                    logger.info(f"已將新支付方式 {new_method_id} 關聯到用戶 {user_id}。")

            # 處理用戶選取的現有支付方式
            for key, value in request.form.items():
                if key.startswith('method_') and value == 'on':
                    try:
                        method_id = int(key.replace('method_', '')) # 從 'method_ID' 中提取 ID
                        # 將選取的支付選項與用戶關聯
                        sql_insert_user_method = "INSERT INTO user_payment_methods (user_id, payment_option_id) VALUES (%s, %s)"
                        cursor.execute(sql_insert_user_method, (user_id, method_id))
                        logger.info(f"已將現有支付方式 {method_id} 關聯到用戶 {user_id}。")
                    except ValueError:
                        # 如果 method_id 無法轉換為整數，則記錄警告
                        logger.warning(f"遇到無效的 method_id: {key}")


            db_conn.commit() # 提交所有資料庫變更
            logger.info(f"用戶 {user_id} 的支付方式已成功儲存。")
            return render_template('save_success.html') # 渲染成功頁面

        except Exception as e:
            if db_conn:
                db_conn.rollback() # 如果發生錯誤，回滾所有變更
            logger.error(f"儲存支付方式時發生錯誤: {e}")
            return f"資料庫錯誤： {e}", 500
        finally:
            db_conn.close()
    else:
        return "資料庫連線失敗。", 500

# --- 主程式進入點 ---
if __name__ == "__main__":
    logger.info('Flask 應用程式啟動中...')
    # 從環境變數獲取 PORT，如果沒有則使用 50000
    port = int(os.environ.get('PORT', 50000))
    # 讓 Flask 應用程式在所有可用的網路介面上監聽
    app.run(host='0.0.0.0', port=port, debug=True) # debug=True 方便開發調試